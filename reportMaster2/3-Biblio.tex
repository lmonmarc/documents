%% -*- eval: (flyspell-mode 1); -*-

\chapter{Bibliothèque de stencils basée sur SYCL}

Au cours du stage a été développée un DSEL de stencils sous la forme d'une bibliothèque \textsf{C++} miniature. Ce DSEL essaie de reprendre les objectifs explicités dans le chapitre précédent, toutefois il s'agit plutôt d'une preuve de faisabilité ce pour quoi tous les objectifs n'ont pas été implémentés (mais leur intégration a été prévue). Ce chapitre se concentre sur la présentation de ce DSEL en ce qui concerne son utilisation, quelques détails d'implantations, ainsi que le travail restant.

\section{Présentation générale}

Le DSEL implémenté s'appuie sur très peu de classes afin de simplifier son utilisation, il s'agit essentiellement de deux classes pour les coefficients (constants ou variables), plusieurs classes pour la description d'une opération (tableaux d'entrées et sorties, fonctions d'accès aux éléments ou aux coefficients telles que décrites dans la section \ref{sec:obj_sem}) et une unique classe pour lancer les calculs. Concrètement l'écriture d'un problème à base de stencils dans le DSEL se fait en cinq étapes :

\begin{enumerate}
\item initialiser les coefficients ;
\item les assembler pour former un stencil au sein d'un objet \emph{stencil};
\item regrouper les informations nécessaires au calcul (stencil, tableaux et fonctions) au sein d'un objet \emph{operation};
\item déclarer une queue de calcul dans le formalisme \textsf{SYCL} ;
\item appeler la méthode de lancement des calcul sur l'objet \emph{operation}.
\end{enumerate}

\subsection{Création des stencils}

Les coefficients peuvent être créés en version constante ou variable, avec les indices de décalage spécifiés dans le \emph{template} de la classe, ils seront donc statiques. La logique de construction n'est pas exactement la même pour les deux classes puisque la version constante nécessite de préciser le type du coefficient (entier, flottant, etc\ldots). Enfin notons que seule la version en deux dimensions a été implémentée et est ici présentée.
\begin{minted}{cpp}
/* la valeur du coefficient est affectée à la construction */
coef_fxd2D<-1, 1, double> c2(0.2);
/* les valeurs du coefficient nécessiteront une fonction tierce */
coef_var2D<0, 0> c1;
\end{minted}

Une fois les coefficients initialisés, il est possible de les rassembler pour former le motif du stencil. Il est d'ailleurs possible de combiner plusieurs stencils ensembles de la même manière. Toutefois il n'est possible d'agréger que des coefficients du constants et du même type entre eux, ou bien que des coefficients variables entre eux, il n'est pas possible de mélanger les deux possibilités.
\begin{minted}{cpp}
/* création d'un stencil à 5 points */
auto st = c1+c2+c3+c4+c5; 
\end{minted}
Il est important de remarquer deux choses sur cet extrait de code : l'usage du mot-clé \textsf{auto} et l'usage de l'opérateur \textsf{+}. Le mot-clé \textsf{auto} permet de cacher à l'utilisateur le vrai type du stencil qui, étant un template, contient de nombreuses informations et serait donc fastidieux à écrire. Concrètement écrire directement le type du stencil reviendrait à écrire les propriétés du stencil sous une forme très peu lisible (tous les indices étant les uns à la suite de autres sur la même ligne), ce qu'il vaut donc mieux éviter. Quant au \textsf{+} il est utilisé pour faire la \og concaténation \fg~des coefficients mais n'a rien à voir avec l'opération mathématique qui est effectuée derrière. Lier les deux pourraient être intéressant, mais complexe à mettre en place car dans la plupart des cas, les opérations utilisées sont des additions.

Les coefficients variables nécessitent l'initialisation d'un tableau tiers, dont le type est basé sur \textsf{SYCL}. Il s'agit d'un \emph{buffer} à une seule dimensions comprenant n'importe quel nombre d'éléments. Ce buffer est alors associé à une fonction d'accès, qui doit veiller à ne pas dépasser les limites du tableau (non vérifié par la compilation). L'exemple de code suivant présente l'équivalent d'un coefficient constant sous forme de coefficient variable.
\begin{minted}{cpp}
/* valeur du coefficient */
float tab_var = 1.0;
/* création du buffer */
coefBuffer = sycl::buffer<float,1>(&tab_var, sycl::range<1> {1});
/* création de la fonction d'accès */
float  fac_coef(int a,int b, int c, int d, 
                sycl::accessor<float, 1, sycl::access::read>  acc) {
  return acc[0];
}
\end{minted}
Bien sûr dans le cas d'un coefficient variable, la fonction d'accès peut être beaucoup plus complexe et peut notamment faire intervenir les quatre variables \verb!a, b, c, d! qui sont les indices globaux puis de décalage de l'élément en cours de calcul, tandis que \verb!acc! est le tableau des coefficients. L'écriture de ces fonctions d'accès n'est pas vraiment aisé, mais elles sont nécessaires dans certains types de calculs comme la chromodynamique quantique.

\subsection{Application des stencils}

Avant de déclencher le calcul, il reste à préciser les informations de l'opération : tableaux d'entrée et sortie notamment, ainsi que leur fonction d'accès. Ces fonctions d'accès sont plus simples puisqu'elles ne font intervenir que les indices globaux, en revanche il est nécessaire d'en définir une pour la sortie et une pour l'entrée, même si les deux accèdent aux éléments de la même façon. Ces deux versions différents sont nécessaires car la fonction du tableau de sortie, dans lequel sont écrits les résultats, doit renvoyer des éléments modifiables et non seulement en lecture seule. Deux prototypes sont donnés en exemple ci-dessous.
\begin{minted}{cpp}
/* Fonction d'accès pour la sortie, notez le & */
float& fdl_out(int a,int b, 
               sycl::accessor<float, 2, sycl::access::write> acc) 
               {return acc[a][b];}
/* Fonction d'accès pour l'entrée */
float  fdl_in(int a,int b, 
              sycl::accessor<float, 2, sycl::access::read>  acc) 
              {return acc[a][b];}
\end{minted}

Les tableaux de l'entrée et de la sortie sont déclarés sous forme de buffers, exactement comme dans le cas précédent à la différence qu'ils sont bien en deux dimensions cette fois. Une fois tous les éléments déclarés, il est donc possible de former l'opération comme dans le code ci-dessous.
\begin{minted}{cpp}
/* assemblage des éléments de l'entrée, dans l'ordre :
 * type, buffer des éléments en entrée, buffer des 
 * coefficients, fonction d'accès aux éléments,
 * fonction d'accès aux coefficients
 */
input_var2D<float, &ioABuffer, &ioBBuffer, &fdl_in, &fac> work_in;
/* assemblage des éléments de sortie, dans l'ordre :
 * type, buffer des éléments en sortie, fonction
 * d'accès aux éléments
 */
output_2D<float, &ioBuffer, &fdl_out> work_out;
/* création de l'opération */
auto op_work = work_out << st << work_in;
\end{minted}
Le code pour les coefficients constants est similaire, seule la description de l'entrée est légèrement simplifiée puisqu'il n'y pas besoin de la fonction d'accès aux coefficients ni du buffer associé. 

Enfin il reste à appeler le calcul, c'est l'étape la plus simple qui n'appuie que sur deux méthodes différentes, adaptées suivant les besoins d'optimisations de l'utilisateur (avec tuilage ou non). Pour lancer les calculs il est nécessaire de déclarer une queue qui contient les informations relatives au matériel disponible et est gérée par \textsf{SYCL}. La découverte du matériel est automatique, la simple déclaration de la variable permet son utilisation. Nous obtenons alors le code de lancement suivant.
\begin{minted}{cpp}
{   
  /* création de la queue */
  sycl::queue myQueue; 
  /* application d'une opération avec tuilage */
  op_work.doLocalComputation(myQueue);
  /* application d'une autre opération sans tuilage */
  op_copy.doComputation(myQueue);
}
\end{minted}

\section{Détails d'implantation}

L'utilisation du \textsf{C++} et notamment de la méta-programmation a permis le résultat présenté ci-dessus. Le fonctionnement interne du DSEL est volontairement caché à l'utilisateur, nous le détaillons donc quelque peu dans cette section, notamment pour la gestion des variables statiques qui est l'un des intérêts principaux de la méta-programmation par template. Cela permet alors de spécialiser les fonctions lors de la compilation et donc de les rendre plus rapides lors de l'exécution. Concrètement la méta-programmation permet d'écrire un code qui sera modifié (ou plus exactement spécialisé) par d'autres parties du code. Par exemple en \textsf{C++} une classe template sera spécialisée pour chacune de ses instances déclarées dans le code et ayant des paramètres différents. La méta-programmation est au cœur de tout le développement du DSEL, elle permet de se placer \og au-dessus \fg~du langage à partir du langage lui-même. Notons que ce principe se retrouve dans d'autres langages informatiques tel que \textsf{Maude}, et même dans les langages naturels \cite{Web6}.

\subsection{Précisions sur le \textsf{C++14} et l'utilisation de \textsf{SYCL}}

C++14 et autres
Expression template \cite{Web4,Art21}
+ ordre des opérations

Partial specialization \cite{Web1}
Typename keyword \cite{Web2}


\subsection{Calcul des paramètres de tuilage}
\label{sec:param_tuile}



\section{\'Evolutions possibles}
\label{sec:evol_biblio}

Reprendre slides : surtout agrégation de stencils
Overlapped tiling \cite{Art17}
Variadic templates \cite{Art6}
Forme des blocs : Diamond Tiling stencil \cite{Art16}


