%% -*- eval: (flyspell-mode 1); -*-

\chapter{\'Evaluation de la bibliothèque}

Le DSEL doit être évalué dans plusieurs domaines : à la fois en matière d'expressivité du langage et à la fois du point de vue des performances matérielles (la rapidité d'exécution). Ces deux évaluations ont été difficiles à réaliser car d'une part l'expressivité est difficilement quantifiable, et d'autre part car le DSEL s'appuie sur la bibliothèque \textsf{triSYCL} qui est seulement un prototype -- une preuve de concept également.


\section{\'Evaluation qualitative}

La qualité du DSEL peut se juger à la facilité d'écriture de code l'utilisant. Globalement il faudrait alors évaluer à quel point la librairie permet d'abstraire le problème qu'elle est censée résoudre (ici la parallélisation de stencils). Plus particulièrement il s'agit de quantifier notamment du pseudo-typage (erreurs sémantiques statiques), du nombre de mots-clés (classes, méthodes), du nombre de symboles, et enfin du nombre de lignes de codes (LOC). Pour des raisons de simplicité seul le nombre de ligne de codes ainsi que le nombre de caractères ont été pris en compte. 

Ces deux nombres ont été comparé entre plusieurs codes d'un même problème de Jacobi en deux dimensions avec un stencil à cinq points. Les différentes versions du code sont :
\begin{enumerate}
\item code de base sans parallélisation ;
\item code \textsf{OpenMP} avec parallélisation naïve ;
\item code \textsf{OpenMP} avec parallélisation par tuilage ;
\item code \textsf{triSYCL} avec parallélisation naïve ;
\item code \textsf{triSYCL} avec parallélisation par tuilage ;
\item code \textsf{DSEL} avec parallélisation et coefficients variables ;
\item code \textsf{DSEL} avec parallélisation et coefficients constants ;
\item code \textsf{OpenCL} avec parallélisation par tuilage.
\end{enumerate}

Les deux versions du DSEL ne se déclinent pas en parallélisation avec tuilage ou naïve puisque celle-ci est simplement choisie par l'appel d'une méthode ou l'autre, dont les noms ne différent que de cinq caractères (qui ont été comptabilisés). Par ailleurs pour comptabiliser les lignes de codes et caractères, toutes les lignes vides n'ont pas été comptabilisées, de même que les commentaires. De plus les conventions de codage (pour les retours à la ligne et la disposition des arguments) sont les mêmes pour les $8$ codes. Enfin aucune entrée/sortie standard (en dehors des erreurs) n'est intégrée dans le décompte des deux métriques ; les seules erreurs reportées se trouvent dans le code d'\textsf{OpenCL}, car c'est à la charge de l'utilisateur de les traiter contrairement aux autres codes (\textsf{OpenMP} n'en n'a pas besoin dans ce cas, et celles de \textsf{triSYCL} sont gérées en interne de même que le DSEL qui s'appuie sur \textsf{triSYCL}).

Les résultats sont reproduits dans le tableau \ref{tab:eval_qual} où l'on peut observer que le DSEL (avec coefficients constants) est le troisième code le plus court avec $42$ lignes, tandis que le plus court (code de base) en comporte $31$. Le DSEL avec coefficients constants se classe cinquième avec $46$ lignes. En ce qui concerne les codes avec tuilage, ils ont deux fois (\textsf{OpenMP}) à cinq fois (\textsf{OpenCL}) plus long que le code de base. Le classement est quasiment identique selon le nombre de caractères (à une inversion près, ne concernant pas le DSEL).

\begin{table}
\floatbox[{\capbeside\thisfloatsetup{capbesideposition={right,center},capbesidewidth=4cm}}]{table}[\FBwidth]
{
\caption{Évaluation du nombre de lignes de codes et de caractères pour différentes implantations d'un problème Jacobi2D.}
\label{tab:eval_qual}
}
{
\begin{tabular}{||c||c|c||}
\hline
implantation & LOCs & caractères \\
\hline
\hline
base & $31$ & $899$ \\
\hline
OpenMP naïf & $32$ & $924$ \\
\hline
OpenMP tuilage & $87$ & $3115$ \\
\hline
triSYCL naïf & $43$ & $1676$ \\
\hline
triSYCL tuilage & $74$ & $3647$ \\
\hline
DSEL variable & $46$ & $1919$ \\
\hline
DSEL constant & $42$ & $1624$ \\
\hline
OpenCL tuilage & $177$ & $6266$ \\
\hline
\end{tabular}
}
\end{table}

En résumé, l'écriture du code grâce au DSEL est du même ordre de grandeur que l'écriture des codes parallélisés naïfs (à quelques lignes près) lors qu'il propose l'optimisation de tuilage. Les autres codes proposant le tuilage étant quant à eux deux à cinq fois plus longs que le code de base, le DSEL permet ainsi une amélioration significative des performances (grâce au tuilage) sans augmenter substantiellement la charge de développement (estimée en LOCs).


\section{Performances quantitatives sur machines dédiées}

Les performances quantitatives s'appuient sur deux métriques : le temps d'exécution et les compteurs \emph{hardwares}. Tandis que la rapidité d'exécution est l'objectif principal de la librairie, les compteurs permettent de comptabiliser indirectement la réutilisation des données, qui plus elle est grande plus elle favorise la rapidité. Le protocole de tests est présenté en premier, avant de préciser plus en détail les résultats de ces mesures.

\subsection{Description du matériel et des cas de tests}
\label{sec:desc_mat_tests}

+ Parler des tuiles au sens vecteur d'éléments

+ Vérification des valeurs numériques 

\subsubsection*{Implantations testées}


\subsubsection*{Machines de tests}


\subsection{Mesures de temps}

(Pour hiérarchisation, \cite{Ths3,Ths4})


\subsection{Mesures de compteurs}

